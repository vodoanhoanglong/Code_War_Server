INSERT INTO public.challenges (id, name, des, image, priority, "startDate", "endDate", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('8fd25ab9-46a7-484e-b0af-a9440f242753', 'Finding the best algorithm - Competing other programers', 'A programming issue could have many solutions. The complexity of the algorithm in the solutions vary depending on the data. Let’s find the best solution to compete against other developers.', 'https://codelearn.io/Themes/TheCodeCampPro/Resources/Images/challenge/vector-challenge.svg', 1, '2021-07-20 00:00:00+00', '2022-07-20 00:00:00+00', 'active', '2022-05-23 03:57:57.050048+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-23 03:57:57.050048+00', NULL);
INSERT INTO public.challenges (id, name, des, image, priority, "startDate", "endDate", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('94694bb5-5f69-4ecf-8f5d-7c327bb343f5', 'Find the fastest search algorithm', 'You might have used the search feature many times with the CTRL + F key combination but did not pay attention or learn about the internal algorithm. For this challenge, you will try to find the fastest text search algorithm to compete other programmers.', 'https://codelearn.io/Themes/TheCodeCampPro/Resources/Images/challenge/vector-challenge.svg', 2, '2021-07-20 00:00:00+00', '2022-07-20 00:00:00+00', 'active', '2022-05-23 03:59:24.830955+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-23 03:59:24.830955+00', NULL);
INSERT INTO public.challenges (id, name, des, image, priority, "startDate", "endDate", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('a8cc1229-0bb0-43f1-a4dd-b88d3db0394f', 'Finding the best algorithm - Competing other programer', 'A programming issue could have many solutions. The complexity of the algorithm in the solutions vary depending on the data. Let’s find the best solution to compete against other developers.', NULL, 3, '2022-05-25 17:57:35+00', '2022-05-29 17:57:35+00', 'active', '2022-05-25 18:01:45.307642+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 18:03:41.19453+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4');
INSERT INTO public.challenges (id, name, des, image, priority, "startDate", "endDate", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('8c7755b1-aaff-4023-b496-00d700e1dd1a', 'Finding the best algorithm - Competing others programers', 'A programming issue could have many solutions. The complexity of the algorithm in the solutions vary depending on the data. Let’s find the best solution to compete against other developers.', NULL, 5, '2022-05-25 18:03:58+00', '2022-06-01 18:03:58+00', 'active', '2022-05-25 18:06:52.026124+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 18:06:52.026124+00', NULL);
INSERT INTO public.challenges (id, name, des, image, priority, "startDate", "endDate", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('20ed92e7-c39d-4759-9823-e1506729f573', 'Finding algorithm - Competing other programers', 'A programming issue could have many solutions. The complexity of the algorithm in the solutions vary depending on the data. Let’s find the best solution to compete against other developers.', NULL, 6, '2022-05-25 18:07:19+00', '2022-05-25 18:07:19+00', 'active', '2022-05-25 18:08:41.353933+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 18:08:41.353933+00', NULL);
INSERT INTO public.contests (id, name, des, "startDate", "endDate", "time", "logoUrl", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('c5d7d512-c691-4508-9acb-565782765a80', 'UTC2 TECH - WAR 2022', '𝐔𝐓𝐂𝟐 - 𝐓𝐞𝐜𝐡 𝐖𝐚𝐫 𝐧𝐚̆𝐦 𝟐𝟎𝟐𝟐 - Một cuộc thi đầy hấp dẫn dành cho sinh viên IT đến từ khắp các trường khác nhau trên mọi miền đất nước. Trải qua 2 năm tổ chức, cuộc thi đã trở thành một trong những sân chơi top đầu dành cho sinh viên IT.', '2022-05-25 18:09:53+00', '2022-05-30 18:09:53+00', 3600000, NULL, 'active', '2022-05-25 18:16:55.434569+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 18:16:55.434569+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4');
INSERT INTO public.contests (id, name, des, "startDate", "endDate", "time", "logoUrl", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('1137e137-4d7e-4512-99d9-67abb17b60b2', 'UTC2 CODE CONTEST', 'Cùng 1 bài toán lập trình nhưng có thể có nhiều lời giải. Độ phức tạp của thuật toán trong các lời giải có thể khác nhau và tùy vào dữ liệu. Bạn hãy tìm ra lời giải tối ưu nhất để thi đấu cùng các lập trình viên khác.', '2022-05-25 18:28:17+00', '2022-06-01 18:28:17+00', 7200000, NULL, 'active', '2022-05-25 18:28:42.195396+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 18:28:42.195396+00', NULL);
INSERT INTO public.contests (id, name, des, "startDate", "endDate", "time", "logoUrl", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('81039554-2fc7-4b24-b302-34f1ad6bbe4c', 'SASUKE CODEWAR', 'Cuộc thi giành cho mọi đối tượng đam mê lập trình, yêu thích công nghệ.', '2022-05-25 18:32:28+00', '2022-06-03 18:32:28+00', 7200000, NULL, 'active', '2022-05-25 18:34:33.735706+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 18:34:33.735706+00', NULL);

INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('bfb857c5-5c0b-4374-864c-494dc166c1c9', 'Find the fastest search algorithm', 'Chắc bạn cũng đã nhiều lần sử dụng tính năng tìm kiếm với tổ hợp phím CTRL + F nhưng lại không để ý hay tìm hiểu tới thuật toán bên trong. Với thử thách lần này bạn hãy thử tìm ra thuật toán tìm kiếm văn bản nhanh nhất cùng với các lập trình viên khác.
### Câu hỏi
Cho hai xâu ký tự `s1` và `s2`, bạn hãy viết hàm trả về số lần xuất hiện của `s2` trong `s1`.
Ví dụ
-   Với `s1 = "abccab", s2 = "ab"` thì output là `countOccurrences(s1, s2) = 2`.
-   Với `s1 = "aaaa", s2 = "aa"` thì output là `countOccurrences(s1, s2) = 3`.
Đầu vào/Đầu ra
-   [Thời gian chạy] 0.5s với C++, 3s với Java và C#, 4s với Python, Go và JavaScript.
-   [Đầu vào] string s1, s2\
    `1 <= s1.size, s2.size <= 500000`
-   [Đầu ra] Integer
[](https://codelearn.io/challenge/thu-thach-9-tim-thuat-toan-tim-kiem-nhanh-nhat/2169334#)', 3, NULL, '[{"time": 500, "input": "abccab ab", "point": 10, "output": "2"}]', '["Challenge"]', NULL, NULL, '94694bb5-5f69-4ecf-8f5d-7c327bb343f5', 'active', '2022-05-23 09:25:46.005164+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-23 09:25:46.005164+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('d32355f2-1999-4eaa-964f-55d74d6e58d5', 'Finding the best algorithm - Competing other programers', 'Cho mảng các xâu ký tự `arr1` và `arr2`. Ứng với mỗi xâu trong `arr2` bạn hãy đếm xem trong `arr1` có bao nhiêu xâu được bắt đầu bởi xâu này. Kết quả trả về sẽ là mảng lưu số lần xuất hiện tương ứng.
Ví dụ
-   Với `arr1 = ["codelearn", "codeit", "coding"], arr2 = ["cod", "code"]` thì output là `numberOfPrefixes(arr1, arr2) = [3, 2]`.
Đầu vào/Đầu ra
-   [Giới hạn thời gian chạy] 1 giây với C++, 6 giây với Java và C#, 8s với Python, GO và Js.
-   [Đầu vào] Array of string arr1\
    `1 <= arr1.size <= 10000`\
    `1 <= arr1[i].size <= 30`
-   [Đầu vào] Array of string arr2\
    `1 <= arr2.size <= 10000`\
    `1 <= arr2[i].size <= 30`
-   [Đầu ra] Array of integer', 3, NULL, '[{"time": 500, "input": "[''codelearn'', ''codeit'', ''coding''] [''cod'', ''code'']", "point": 10, "output": "[3, 2]"}]', '["Challenge"]', NULL, NULL, '8fd25ab9-46a7-484e-b0af-a9440f242753', 'active', '2022-05-23 09:21:47.969213+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-23 09:21:47.969213+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('c87d7996-bda9-4876-8eee-1833e1d317b3', 'billiardWithoutPockets', 'Recently, Van falls in love with [billiards](https://en.wikipedia.org/wiki/Billiard) again. He spent a lot of time practicing. One of his exercises was to turn on the cushion with one ball, by covering all ball pockets. With each hit of the ball Van wants to calculate the number of times the ball hits the cushion and then bounces, the ball can bounce many times and this is a bit too much for his calculation ability. As a programmer, please help him handle this problem:
    Given a billiard table (without ball pockets) a rectangle of horizontal and vertical dimensions will be `m`, `n`, calculate how many times a ball touches the cushion (the edge of the table) when moving a certain distance.
    The coordinate of the marble is initially `x`, `y` given and the ball is always shot at a 45 degree angle (in the top right direction of the table). The distance (the stronger the hand force, the greater the length) of the ball is `d`.
![](https://codelearn.io/Media/Default/Users/vannc/anh/BIDA_1200px-A_carom_table_in_Caf%C3%A9_Z%C3%A9phyr,_Paris,_France,_14_January_2007.jpg)
Example:
-   With `m = 18, n = 5, x = 5, y = 2, d = 17`, the output should be `billiardWithoutPockets(m, n, x, y, d) = 5`.\
    --> Describe the path of a ball starting from the position (5,2) moved in a billiard table of size 18, 5 where `d` is 17 as follows: ("O" is the starting position and the path of the ball is described by the character "."). We can see the number of times the ball hits on cushions is 5.
                 ![](https://codelearn.io/Media/Default/Users/vannc/anh/bidasida.jpg)
-   *Input/Output*:
-   [Execution time limit] 0.1s for C++, 0.6s for Java and C#, 0.8s for Python, Go and JavaScript.
-   [Input] Integers    
           2 < m, n <= 2020\
           1 < x < m\
           1 < y < n\
           0 <= d <= 10^6
-   [Output] Integer
    Number of hits on the cushion.', 2, NULL, '[{"time": "600", "input": "18 5 5 2 17", "point": 5, "output": "5"}, {"time": "600", "input": "18 5 15 2 6", "point": 5, "output": "2"}]', '["C++", "C"]', NULL, NULL, NULL, 'active', '2022-05-25 17:15:42.587953+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 17:15:42.587953+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('0d564a4d-3901-419a-973c-ad78e498b1c6', ' stringAB', 'Given 2 numbers `n` and `k`. Your task is to find all strings of length `n` which contain only 2 characters `A` and `B` such that there is only one substring of `k` letter `A` repeating consecutively. The answers are sorted in lexicographical order (alphabetical order). 
Example
-   For `n = 2, k = 1`. The output should be: `["AB", "BA"]`
-   For `n = 3, k = 2`. The output should be: `["AAB", "BAA"]`
Input/Output
-   [execution time limit] 0.5s
-   [input] integer n, k
          `2 <= n <= 15`
          `1 <= k <= n`
-   [output] array.string
    The list of strings of length `n` which contain only 2 characters A and B such that `k` letter A repeat consecutively', 2, NULL, '[{"time": "3000", "input": "2 1", "point": 5, "output": "[\"AB\",\"BA\"]"}, {"time": "3000", "input": "3 2", "point": 5, "output": "[\"AAB\",\"BAA\"]"}]', '["string", "bruteforce"]', NULL, NULL, NULL, 'active', '2022-05-25 17:19:19.411557+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 17:19:19.411557+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('507698aa-c5d7-4d23-885c-c404dfe0c146', ' dieHard', 'Trò chơi rất đơn giản. Ban đầu, bạn có lượng máu `''H''` và lượng giáp `''A''`. Bất cứ lúc nào bạn cũng có thể sống ở bất kỳ nơi nào trong ba nơi - lửa, nước và không khí. Sau mỗi đơn vị thời gian, bạn phải thay đổi nơi sinh sống. Ví dụ, nếu bạn hiện đang sống trong lửa, bạn có thể bước vào nước hoặc không khí.
![](data:image/png;base64,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)
-   Nếu bạn bước lên không trung, sức khỏe của bạn tăng thêm `3` và áo giáp của bạn tăng thêm` 2`.
-   Nếu bạn bước xuống nước, sức khỏe của bạn giảm `5` và áo giáp của bạn giảm `10`.
-   Nếu bạn bước vào lửa, sức khỏe của bạn giảm `20` và áo giáp của bạn tăng thêm `5`.
-   Nếu sức khỏe hoặc áo giáp của bạn trở thành `<= 0`, bạn sẽ chết ngay lập tức.
Tìm thời gian tối đa bạn có thể sống sót.
Ví dụ:
-   Với `H = 2, A = 10` thì `dieHard(h,a) = 1.`\
    Giải thích: đầu tiên bạn chọn ô lửa. Tiếp theo sẽ di chuyển như sau: `Fire(2,10) -> Air(5,12) -> Fire(-15,17) or Water(0,2) (end)`
Đầu vào/đầu ra:
-   Giới hạn thời gian chạy: 0.5 giây với C++, 3 giây với Java và C#, 4 giây với Python, GO và Js.
-   [Đầu vào] integer\
    Lượng máu ban đầu.\
    `1 <= h <= 1000`
-   [Đầu vào] integer\
    Lượng giáp ban đầu.\
    `1 <= a <= 1000`
-   [Đầu ra] integer\
    Thời gian tối đa bạn có thể sống
[](https://codelearn.io/training/detail/536385#)', 1, NULL, '[{"time": "3000", "input": "2 10", "point": 5, "output": "1"}, {"time": "3000", "input": "4 4", "point": 5, "output": "1"}]', '["algorithm", "handling"]', NULL, NULL, NULL, 'active', '2022-05-25 17:20:33.090409+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 17:20:33.090409+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('a26c66c6-e3cb-4a03-9eec-b4bf8b1ae676', ' extrapolateRanges', '[TungNM1](https://codelearn.io/profile/3573)
Medium
![](https://codelearn.io/Themes/TheCodeCampPro/Resources/Images/code-learn/task-point.svg?v=11)150 Points
Character limit: 3000
You are given a string of positive numbers in no specific order, delimited by commas. Your job is to return a string of ranges extrapolated from the input, in ascending order. If the input string contains any characters other than positive integers and commas, the string `"undefined"` should be returned.
Example:
-   For `str = "5,10,11,20,21,12,13,100,1,2,3"`, the output should be\
    `extrapolateRanges(str) = "1-3,5,10-13,20-21,100"`.
Input/Output:
-   [execution time limit] 0.5 seconds
-   [input] string str
    String of positive integers, delimited by commas.
    *Guaranteed constraints:*\
    `1 ≤ str.length < 105`.
-   [output] string
    A string of comma delimited ranges or `"undefined"`. A range can be a single integer, or an inclusive list of integers specified in the following format: `{min}-{max}` (e.g. `5-9`).', 2, NULL, '[{"time": "3000", "input": "\"5,10,11,20,21,12,13,100,1,2,3\"", "point": 5, "output": "\"1-3,5,10-13,20-21,100\""}, {"time": "3000", "input": "\"0,4,5,6,-9,10,500\"", "point": 5, "output": "\"undefined\""}]', '["Algorithm", "string"]', NULL, NULL, NULL, 'active', '2022-05-25 17:23:27.267884+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 17:23:27.267884+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('0942378b-bcd5-423d-8a5b-0769f81e0a2a', ' autoCorrect', 'Hey, let''s do one more text editor themed challenge!
Autocorrect is a feature commonly found in mobile phones - when the user does a typo, it gets automatically replaced with the closest matching word from a list of known words.
Given a set of known words, `trainingWords`, and a sequence of words input by the user, `typedWords`, our task is to find the string we''ll get once the elements of typedWords have been autocorrected. Since parsing words can be tedious, both `trainingWords` and `typedWords` are given as arrays of strings. The final text should be output as a single string (words joined by spaces).
How to select the closest word?\
To compare strings, we''ll be using Levenshtein distance, which is basically a measure of how many edits would be required in order to transform one word into another. An edit is one of the following three operations:
-   insertion - add a new character to some part of the string\
    (eg: from `"awkward"` to `"bawkward"`)
-   deletion - remove a character from some part of the string\
    (eg: from `"friend"` to `"fiend"`)
-   replacement - replace one character in the string with a different character\
    (eg: from `"nice"` to `"vice"`)
For any string in typedWords that doesn''t occur in trainingWords, we''ll replace it with the string from trainingWords that''s considered closest according to Levenshtein distance. If there''s a tie for the closest match, choose the one that appears earliest in trainingWords. Comparisons are case-sensitive.
Example
-   For `trainingWords = ["without", "night", "text", "cellar", "requirement", "some", "park", "instinct", "flourish", "computing", "vision", "mean", "round", "mistakes", "vain", "exemption", "fast"]` and t`ypedWords = ["some", "tex", "whith", "mistakesd"]` the output should be autocorrect(trainingWords, typedWords) = `"some text without mistakes"`
Input/Output
-   [execution time limit] 0.5 seconds 
-   [input] array.string trainingWords
    The set of words our autocorrect algorithm has been trained on. All of the words in the output will be chosen from this list. All words consist of uppercase and lowercase letters only. There are no repeat words in the list.
    *Guaranteed constraints:\
    *1 ≤ trainingWords.length ≤ 2000\
    1 ≤ trainingWords[i].length ≤ 50.
-   [input] array.string typedWords
    A list of words typed by the user (in order). Each word will be replaced with the closest word from trainingWords(according to Levenshtein distance). All words consist of uppercase and lowercase letters only.
    *Guaranteed constraints:\
    *0 ≤ typedWords.length ≤ 2000,\
    1 ≤ typedWords[i].length ≤ 50.
-   [output] string
    The resulting sentence after typedWords have been autocorrected, joined by spaces.', 2, NULL, '[{"time": "12000", "input": "[\"without\",   \"night\",   \"text\",   \"cellar\",   \"requirement\",   \"some\",   \"park\",   \"instinct\",   \"flourish\",   \"computing\",   \"vision\",   \"mean\",   \"round\",   \"mistakes\",   \"vain\",   \"exemption\",   \"fast\"] [\"some\",   \"tex\",   \"whith\",   \"mistakesd\"]", "point": 5, "output": "\"some text without mistakes\""}, {"time": "12000", "input": "[\"hey\",   \"wicked\",   \"have\",   \"a\",   \"great\",   \"day\"] [\"hey\",   \"take\",   \"a\",   \"nice\",   \"day\"]", "point": 5, "output": "\"hey have a wicked day\""}]', '["Algorithm", "Lenvenshtein distance"]', NULL, NULL, NULL, 'active', '2022-05-25 17:30:23.80374+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 17:30:23.80374+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('b38f9d97-da92-42a6-9951-fa2bb76622e0', ' Kinv', 'Cho một dãy số `a1.. aN`. Một nghịch thế là một cặp số `u, v` sao cho `u < v` và `au > av`. Nhiệm vụ của bạn là đếm số nghịch thế.
Ví dụ:
-   `Solve(3,1,2)=2` ( giải thích : các cặp nghịch thế ở vị trí : `1 và 3` , `1 và 2 ).`
Đầu vào/Đầu ra:
-   [Thời gian chạy] 0.5s (C++), 3s (Java, C#), 4s (Python,JavaScript).
-   [Đầu vào] array.integer `chuỗi a.(``độ dài chuỗi <=3*1e4, a[i] <=1e6 với mọi i)`
-   [Đầu ra] integer : kết quả đề bài.', 1, NULL, '[{"time": "4000", "input": "[3,1,2]", "point": 5, "output": "2"}, {"time": "4000", "input": "[10,10,8,2,5]", "point": 5, "output": "8"}]', '["data structure"]', NULL, NULL, NULL, 'active', '2022-05-25 17:31:56.676033+00', 'b40c81cf-d0ed-482f-b616-a9e4b252fc33', '2022-05-25 17:31:56.676033+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('a2b99572-797c-49c4-8fac-27ac415a5894', ' circleRotation', 'Given an array `arr` containing integer elements. Performs a rotation by moving an element from the top to the bottom.
For example:
-   For `arr = [1,2,3,4,5]` ---> `[2,3,4,5,1]` ---> `[3,4,5,1,2]` ---> ...
What is the element at the beginning of the array after `d` rotations?
Input/ouput:
-   [Execution time] 0.5s for C++, 3s for Java and C#, 4s for Python, Go and JavaScript.
-   [Input] vector<int> arr\
    `1 <= arr.length() <= 10^6 <= arr[i] <= 10^9`
-   [Input] int d\
    Number of rotations. `0 <= d <= 10^18`
-   [Output] Integer\
    The first element of the array.', 1, NULL, '[{"time": "4000", "input": "[1,5,1,2,2] 3", "point": 5, "output": "2"}, {"time": "4000", "input": "[1,2,3,4,5] 3", "point": 5, "output": "4"}]', '["array"]', NULL, NULL, NULL, 'active', '2022-05-25 17:33:11.770636+00', 'b40c81cf-d0ed-482f-b616-a9e4b252fc33', '2022-05-25 17:33:11.770636+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('21c4040d-d918-4e88-871b-8d3df8944466', ' sumOfThree', 'The lesson of divisibility in integers, James discovers an interesting thing: The sum of three consecutive integers is divisible by 3. Given a string that represents a number, help James check if the number can be written as the sum of 3 consecutive integers or not. Returns `true` if possible, `false` otherwise. If it is not an integer, `false` is returned
For example:
-   For `s = "33"` thì `sumOfThree = true`\
    Explanation: The number `33` can be written to sum of `10 + 11 + 12` which are 3 consecutive integers, so it returns `true`.
Input/Output:
-   [Execution time] 0.5s for C++, 3s for Java and C#, 4s for Python, Go and JavaScript.
-   [Input] String s\
    `s.length < 9`
-   [Output] Boolean\
    Returns `true` if the number is the sum of 3 consecutive integers, `false` otherwise.
[](https://codelearn.io/training/detail/2290280#)', 1, NULL, '[{"time": "4000", "input": "\"33\"", "point": 5, "output": "true"}, {"time": "4000", "input": "\"180\"", "point": 5, "output": "true"}]', '["math", "number"]', NULL, NULL, NULL, 'active', '2022-05-25 17:35:06.784125+00', 'b40c81cf-d0ed-482f-b616-a9e4b252fc33', '2022-05-25 17:35:06.784125+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('60447ed0-b22a-40f7-a7e4-bae991608367', ' Max Distance', 'Ở đất nước X, chính phủ muốn chia N con bò ra thành K nhóm (mỗi nhóm có ít nhất 1 con bò) sao cho 2 con bò ở 2 nhóm khác nhau phải di chuyển 1 vài kilomet để gặp nhau. Bò x và Bò y `(1 ≤ x < y ≤ N)` sẽ phải di chuyển `(2019201913x+2019201949y) mod ``2019201997` kilomet để gặp nhau.\
Giả sử bạn đã chia được n con bò vào k nhóm (mỗi nhóm có ít nhất 1 con bò), gọi M là số kilomet ít nhất mà 2 con bò bất kỳ ở 2 nhóm khác nhau phải đi để gặp nhau.\
Bạn hãy tìm cách chia để M là lớn nhất.
Ví dụ:
-   Với `n = 3, k = 2` thì đáp án là `2019201769.`
-   Giải thích:
    -   Bạn được cho 3 con bò và phải chia vào 2 nhóm sao cho mỗi nhóm đều có ít nhất 1 con bò.
    -   Cách chia tối ưu là:
        -   Nhóm 1: Bò số 1
        -   Nhóm 2: Bò số 2 và 3.
        -   Ta có: Bò 1, 3 phải di chuyển `2019201769 km` để gặp nhau. Bò 1, 2 phải di chuyển `2019201817 km` để gặp nhau. 
        -   Đáp án là `Mmax = min(2019201769, 2019201817) = 2019201769.`
-   Trong bài này bạn sẽ được cho `T` test, mỗi test có dạng `ni,ki .`
[Đầu vào/ Đầu ra]:
-   [Giới hạn thời gian]: 0.5s với C++, 3s với Java & C#, 4s với Python,Go,Js.
-   [Đầu vào]: 1 mảng T gồm `|T|` cặp số `(ni,ki) (1 ≤ ni ≤ 7500) (2 ≤ ki ≤ ni) (1 ≤ |T| ≤ 105).`
-   [Đầu ra]: Gồm |`T|` số tương đương với đáp án của test thứ i.', 3, NULL, '[{"time": "3000", "input": "[[3,2]]", "point": 5, "output": "[2019201769]"}, {"time": "3000", "input": "[[8,7],[9,3],[6,6],[6,5]]", "point": 5, "output": "[2019201109,2019201397,2019201289,2019201373]"}]', '["math", "USACO"]', NULL, NULL, NULL, 'active', '2022-05-25 17:36:42.473461+00', 'b40c81cf-d0ed-482f-b616-a9e4b252fc33', '2022-05-25 17:36:42.473461+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('487b947e-8a8e-4949-87ad-c796e758b47b', 'Total_path_verion_III (public version)', 'Bài này có 3 version và đây là version III.
Điểm khác của version III với version I và version II là bài này có giới hạn T lớn hơn và số lượng đỉnh của đa giác là k.
Bạn được cho 1 hình chóp k-giác `A1A2...Ak-1Ak` với đỉnh `Ak` là đỉnh của hình chóp tứ giác và k-1 đỉnh `A1, A2, ... , Ak-1, Ak` là đáy. Ngoài ra ở mặt đáy, với 2 đỉnh không kề nhau ta nối 2 đỉnh đó lại. Lúc này ta có hình chóp k-giác với `k*(k-1)/2` cạnh (tức là với 2 đỉnh trong k đỉnh, ta đều có 1 cạnh nối 2 đỉnh đó). Chú kiến Alex ban đầu đứng ở đỉnh `A`k . Chú kiến này rất hiếu động và không thể đứng im 1 chỗ tại mỗi thời điểm, do đó với mỗi thời điểm chú kiến phải di chuyển tới 1 trong các đỉnh kề với đỉnh mà chú đang đứng thông qua các cạnh của hình chóp k-giác. Do chú kiến di chuyển liên tục như vậy nên thầy Otto muốn biết rằng sau `n` thời điểm thì có thể có bao nhiêu con đường khác nhau tạo ra sao cho chú kiến Alex ban đầu từ đỉnh `Ak` , di chuyển qua `n` cạnh và kết thúc ở đỉnh `Ak`.
Ví dụ:
-   Với `n = 2, k = 4` tức đây là hình chóp có 4 đỉnh và chú kiến Alex phải đi qua 2 cạnh thì ta sẽ có 3 con đường có thể tạo ra: 
    -   `A4 - A1 - A4.`
    -   `A4 - A2 - A4.`
    -   `A4 - A3 - A4.`
[Đầu vào/Đầu ra]:
-   Giới hạn thời gian]: 3s với C++, 18s với Java & C#, 24s với Python,Go,Js.
-   [Đầu vào]: Số tự nhiên `T (1 ≤ T ≤ 5 x 105)` biểu thị số test mà thầy Otto muốn tính.
-   [Đầu vào]: 1 vector gồm `T` cặp số, mỗi số có dạng `(ki  ni) (4 ≤ ki ≤ 1018), (1 ≤ ni ≤ 1018)` biểu thị số đỉnh của hình chóp và số cạnh mà chú kiến Alex phải đi qua tương ứng với test `i`.
-   [Đầu ra]: Arrays of Integers, gồm T số, mỗi số biểu thị số lượng con đường có thể tạo ra theo modulo `109+7`.
[Mô tả các test]:
-   Test 1 → 5: `1 ≤ T ≤ 10; k,n ≤ 103.` 
-   Test 6 → 10: `11 ≤ T ≤ 103 ; k,n ≤ 103. `
-   Test 11 → 15: `1 ≤ T ≤ 10 ; 103 ≤ k,n ≤ 106. `
-   Test 16 → 20: `1 ≤ T ≤ 102 ; 106 ≤ k,n ≤ 109.` 
-   Test 21 → 25: `1 ≤ T ≤ 5x105 ; 1 ≤ k,n ≤ 109. `
-   Test 26 → 30: `1 ≤ T ≤ 5x105 ; 1 ≤ k,n ≤ 1018. `
-   Test 31: `T = 5x105.`
[](https://codelearn.io/training/detail/14070350#)', 2, NULL, '[{"time": "180000", "input": "1 [[4,2]]", "point": 5, "output": "[3]"}, {"time": "18000", "input": "2 [[210,122],[51,753]]", "point": 5, "output": "[31514835,575576069]"}]', '["math"]', NULL, NULL, NULL, 'active', '2022-05-25 17:38:24.609218+00', 'b40c81cf-d0ed-482f-b616-a9e4b252fc33', '2022-05-25 17:38:24.609218+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('38cf06a5-a2ec-4866-aef7-51229a2d17ad', ' Decorating Cake', 'Bạn được cho 1 chiếc bánh hình chữ nhật gồm `m x n` miếng bánh nhỏ. Bạn muốn trang trí cho bánh bằng cách dùng máy xịt kem qua tất cả các miếng bánh. Bạn có thể bắt đầu từ 1 miếng bánh bất kỳ, hướng máy xịt theo 1 trong 4 hướng trên, dưới, trái, phải và xịt kem về phía trước hoặc quay 90° (quẹo trái hoặc phải). Bạn chỉ được xịt kem trong phạm vi chiếc bánh.\
Bạn hãy tính số lần tối thiểu mà máy xịt kem phải quay `90°` để có thể đi qua tất cả miếng bánh.
Ví dụ: 
-   Với `m = 2, n = 3` thì đáp án là 2.
-   Giải thích:
-   ![Illustration](https://scontent.fsgn5-12.fna.fbcdn.net/v/t1.15752-9/271726738_355992962582246_8388967798864651123_n.png?_nc_cat=103&ccb=1-5&_nc_sid=ae9488&_nc_ohc=pX0sJ43llHgAX9iYsN8&_nc_ht=scontent.fsgn5-12.fna&oh=03_AVJgJX4uRv28Ot7ddKmVryu85B4v00LwPFgiIfGdz-2GEQ&oe=6209EC89)
-   Xuất phát từ ô `(1,1)` và quay phải `(90°)` 2 lần.
-   Trong bài này bạn sẽ được cho T test mỗi test sẽ có dạng `(mi, ni). `
[Đầu vào/ Đầu ra]:
-   [Giới hạn thời gian]: 0.5s với C++,3s với Java & C#,4s với Python,Go,Js.
-   [Đầu vào]: Mảng T gồm các cặp số `mi, ni. (1 ≤ |T| ≤ 105) (1 ≤ mi, ni ≤ 1018).`
-   [Đầu ra]: Gồm `|T|` số tương ứng với đáp án của test thứ i.', 1, NULL, '[{"time": "3000", "input": "[[2,3]]", "point": 5, "output": "[2]"}, {"time": "3000", "input": "[[4,8],[10,3],[5,6],[4,5],[2,7],[8,4]]", "point": 5, "output": "[6,4,8,6,2,6]"}]', '["implementation"]', NULL, NULL, NULL, 'active', '2022-05-25 17:40:45.252837+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 17:40:45.252837+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('cf7c37a1-ddec-4c5c-9240-2ac30a5ab3b8', ' Connecting Points', 'Trên mặt phẳng tọa độ Descartes, bạn được cho `n` điểm, điểm thứ `i` có tọa độ `(xi,yi)`. Hai điểm `A(xA,yA)` và `B(xB,yB)` gọi là kết nối với nhau nếu `(xA - xB)2 + (yA - yB)2 ≤ k` . Nếu 2 điểm A,B kết nối với nhau và 2 điểm B,C kết nối với nhau thì 3 điểm A,B,C cũng được coi là kết nối với nhau.\
Bạn hãy tìm giá trị k nhỏ nhất để n điểm kết nối được với nhau.
Ví dụ:
-   Với `n = 4` và các điểm `(1,3) (5,4) (7,2) (6,1)` thì đáp án là `17`.
[Đầu vào/Đầu ra]:
-   [Giới hạn thời gian]: 1s với C++,  6s với Java & C#,  8s với Python,Go,Js.
-   [Đầu vào]: 
    -   Số tự nhiên `n` biểu thị số điểm trên tọa độ Descartes. `(1 ≤ n ≤ 1000).`
    -   Mảng `G` gồm `n` điểm, mỗi điểm có dạng `(xi,yi).(0 ≤ xi,yi ≤ 25000).`
-   [Đầu ra]:
    -   Giá trị k nhỏ nhất thỏa.', 3, NULL, '[{"time": "6000", "input": "4 [[1,3],[5,4],[7,2],[6,1]]", "point": 5, "output": "17"}, {"time": "6000", "input": "9 [[2,1],[5,1],[3,6],[8,1],[10,7],[7,0],[7,1],[1,4],[5,8]]", "point": 5, "output": "26"}]', '["binary search"]', NULL, NULL, NULL, 'active', '2022-05-25 17:42:15.974757+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 17:42:15.974757+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('830636f1-7097-42bb-8a47-2bcbe5fd7336', ' Sum Of Exponential Polynomial Version I', 'Bài này có 2 version. Đây là version I.
Bạn được cho 2 số tự nhiên `n` và `k`. Bạn hãy tính tổng` (1k + 2k + 3k + ... + nk) mod 109 + 7.`
Ví dụ:
-   Với `n = 4` và `k = 2` thì ta có `(12 + 22 + 32 + 42) mod (109 + 7) = 30.`
[Đầu vào/Đầu ra]:
-   [Giới hạn thời gian]: 1s với C++,  6s với Java & C#,  8s với Python,Go,Js.
-   [Đầu vào]: 
    -   Số tự nhiên `n` và `k` `(1 ≤ n ≤ 105) (1 ≤ k ≤ 20). `
-   [Đầu ra]:
    -   Đáp án của tổng trên.', 1, NULL, '[{"time": "6000", "input": "4 2", "point": 5, "output": "30"}, {"time": "6000", "input": "23 5", "point": 5, "output": "28007376"}]', '["implementation"]', NULL, NULL, NULL, 'active', '2022-05-25 17:43:35.180731+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 17:43:35.180731+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('76738f3b-d695-44ab-bf3d-8e6dc12357cf', ' Sum Of Exponential Polynomial Version II', 'Bài này có 2 version. Đây là version II.
Bạn được cho 2 số tự nhiên `n` và `k`. Bạn hãy tính tổng` (1k + 2k + 3k + ... + nk) mod 109 + 7.`
Ví dụ:
-   Với `n = 4` và `k = 2` thì ta có `(12 + 22 + 32 + 42) mod (109 + 7) = 30.`
[Đầu vào/Đầu ra]:
-   [Giới hạn thời gian]: 1s với C++,  6s với Java & C#,  8s với Python,Go,Js.
-   [Đầu vào]: 
    -   Số tự nhiên `n` và `k` `(1 ≤ n ≤ 1018) (1 ≤ k ≤ 100). `
-   [Đầu ra]:
    -   Đáp án của tổng trên.', 2, NULL, '[{"time": "6000", "input": "4 2", "point": 5, "output": "30"}, {"time": "6000", "input": "10 9", "point": 5, "output": "574304978"}]', '["math"]', NULL, NULL, NULL, 'active', '2022-05-25 17:44:34.627169+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 17:44:34.627169+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('aa47492a-69b7-4151-a406-f3073f24cf16', ' Beautiful Sequence', 'Alexander là 1 người rất thích cái đẹp. Vẻ đẹp từ những loài hoa, những vì sao, những con số đều làm Alexander mê mẩn. Sau nhiều năm nghiên cứu về vẻ đẹp, Alexander phát hiện ra những con số đều mang 1 ý nghĩa nào đó của vũ trụ, như số cánh hoa, số vòng xoáy trên mỗi thiên hà quan sát được từ vũ trụ, chúng đều là số Fibonacci. Hiểu được tâm lý của Alexander, thầy X (thành viên của tổ chức trí tuệ Mensa) đã đố anh 1 bài toán. Bài toán như sau:
Cho 1 dãy N loài hoa từ 1 tới N được sắp xếp từ trái sang phải. `Flower = (1, 2, ..., N)`. Thầy X chọn 2 loài hoa trong N loài hoa trên và đổi chỗ chúng. Một phép đổi chỗ gọi là "Beautiful" nếu tồn tại 1 số tự nhiên M `(1 ≤ M < N)` sao cho tổng M loài hoa đầu tiên bằng tổng N - M loài hoa cuối cùng. Nhiệm vụ của bạn là hãy tính số phép đổi chỗ "Beautiful".
Ví dụ: 
-   Xét N = 3. Lúc này ta có Flower = (1,2,3). Ta có 2 phép đổi chỗ "Beautiful"):
    -   Phép 1: Phép đổi chỗ loài hoa 1 và loài hoa 3. Lúc này ta có Flower = (3, 1, 2). Phép này "Beautiful" vì tồn tại M = 1 thỏa mãn tính chất của phép đổi "Beautiful".
    -   Phép 2: Phép đổi chỗ loài hoa 1 và loài hoa 2. Lúc này ta có Flower = (2, 1, 3). Phép này "Beautiful" vì tồn tại M = 2 thỏa mãn tính chất của phép đổi "Beautiful".
    -   Lúc này với N = 3, ta có đáp án là 2 phép biến đổi "Beautiful".
[Đầu vào/Đầu ra]:
-   [Giới hạn thời gian]: 1s với C++, 6s với Java & C#, 8s với Python,Go,Js.
-   [Đầu vào]: 
    -   Số tự nhiên `T (1 ≤ T ≤ 106)` biểu thị số truy vấn.
    -   Array of Integer a, bao gồm `T` số, mỗi số biểu thị 1 số tự nhiên `ai  , (1 ≤ ai ≤ 109)` là số loài hoa được đưa ra. Nhiệm vụ của bạn là trả lời với mỗi truy vấn.
-   [Đầu ra]:
    -   1 vector gồm T số tương ứng với số T truy vấn.', 3, NULL, '[{"time": "6000", "input": "5 [1,2,3,4,7]", "point": 5, "output": "[0,0,2,2,3]"}, {"time": "6000", "input": "2 [585,139]", "point": 5, "output": "[0,41]"}]', '["binary search"]', NULL, NULL, NULL, 'active', '2022-05-25 17:45:43.398902+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 17:45:43.398902+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('26392566-f3d5-4565-ba27-bfc1f102d73d', 'Tìm ước số lớn nhất', 'Cho mảng các số nguyên `arr`, bạn hãy viết hàm trả về ước số lớn nhất mà khác chính nó của từng phần tử trong `arr`.
Ví dụ
-   Với `arr = [3, 20, 9]` thì output là `largestDivisors(arr) = [1, 10, 3]`.\
    Giải thích: ước số lớn nhất mà khác chính nó của `3, 20, 9` lần lượt là `[1, 10, 3]`.
-   Với `arr = [7, 91, 56]` thì output là `largestDivisors(arr) = [1, 13, 9]`.
Đầu vào/Đầu ra
-   [Giới hạn thời gian chạy]: 1s với C++, 4s với Java và C#, 8s với Python, GO và Js
-   [Đầu vào] Array of integers arr\
    `1 <= arr.size <= 1000`\
    `2 <= arr[i] <= 1012\
    `
-   [Đầu ra] Integer', 1, NULL, '[{"time": "3000", "input": "[3, 20, 9]", "point": 5, "output": "[1, 10, 3]"}, {"time": "3000", "input": "[7, 91, 56]", "point": 5, "output": "[1,13,28]"}]', '["Challenge"]', 'c5d7d512-c691-4508-9acb-565782765a80', NULL, NULL, 'active', '2022-05-25 18:20:36.153745+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 18:20:36.153745+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('19aeaf7f-7dc2-486b-9f43-162d076db21b', ' Counting Star', '### Đề bài:
     Lĩnh vực thiên văn học đã được nâng cao đáng kể thông qua việc sử dụng công nghệ máy tính. Các thuật toán có thể tự động khảo sát hình ảnh kỹ thuật số của bầu trời đêm, tìm kiếm các mẫu mới.
Đối với vấn đề này, bạn nên viết một chương trình phân tích để đếm số lượng các ngôi sao có thể nhìn thấy trong một hình ảnh bitmap. Một hình ảnh bao gồm các pixel và mỗi pixel có màu đen hoặc trắng (được biểu thị bằng các số 1 và 0, tương ứng). Tất cả các pixel đen được coi là một phần của bầu trời và mỗi pixel trắng được coi là một phần của ngôi sao. Các pixel màu trắng liền kề theo chiều dọc hoặc chiều ngang là một phần của cùng một ngôi sao.
    Bạn được cung cấp ma trận `0-1` biểu thị hình ảnh bitmap của bầu trời với chiều dài cạnh lần lượt là `m` và `n`( `1 <= n,m <=100`). Yêu cầu bạn hãy đếm số lượng ngôi sao có trên bầu trời.
![Từ khi vẫn còn sống trong các hang động, người cổ đại đã sớm phát hiện sao  Ngưu Lang - Chức Nữ - DKN News](https://www.dkn.news/wp-content/uploads/2017/10/nguoi-tien-su-hang-lascaux-phap-ban-do-thien-van-ngoi-sao-7.png)
Đầu vào/Đầu ra
-   [Thời gian chạy] 0.5s với C/C++, 3s với Java và C#, 4s với Python, Go và JavaScript.
-   [Đầu vào] Matrix of Integer matrix\
    matrix.size <=100\
    matrix[i].size <=100\
    0 <= matrix[i][j] <=1
-   [Đầu ra] Integer\
    Số lượng ngôi sao', 1, NULL, '[{"time": "3000", "input": "[[1,0],[0,1]]", "point": 5, "output": "2"}, {"time": "3000", "input": "[[1, 0, 1, 1, 1, 1, 1, 1, 1, 1],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[1, 0, 1, 1, 1, 1, 1, 1, 1, 1]]", "point": 5, "output": "1"}]', '["BFS"]', NULL, NULL, NULL, 'active', '2022-05-25 17:47:05.471168+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 17:47:05.471168+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('f38ca22f-3860-4d2c-8db2-5bff03f061ee', ' Counting bit one', 'Bạn được cho 1 vector T gồm các số, với mỗi số `Ti` bạn hãy đếm số lượng bit 1 khi được viết dưới dạng nhị phân của các số từ 1 tới `Ti` . 
Ví dụ: `T = (3,1,5)` thì đáp án là` (4,1,7)`.
-   Với `T0 = 3` thì ta có `3` số là `1,2,3` mỗi số khi biểu diễn dưới dạng nhị phân lần lượt là: `01, 10, 11`. Tổng cộng có 4 bit 1.
-   Với `T1 = 1` thì ta có `1` số là `1` được biểu diễn dưới dạng nhị phân là `1` . Tổng cộng có 1 bit 1.
-   Với `T2 = 5` thì ta có `5` số là `1,2,3,4,5` mỗi số khi biểu diễn dưới dạng nhị phân là `001, 010, 011, 100, 101`. Tổng cộng có 7 bit 1.
[Đầu vào/Đầu ra]:
-   Giới hạn thời gian]: 1s với C++, 6s với Java & C#, 8s với Python,Go,Js.
-   [Đầu vào]: 1 vector T gồm các số `Ti` `(1 ≤ T.size() ≤ 105)` `(1 ≤ Ti ≤ 1015).`
-   [Đầu ra]: 1 vector có kích thước tương đương với vector T, mỗi số biểu thị số bit 1 từ `1` tới `Ti` .
[Mô tả về các test]:
-   Test 1 -> 3: `1 ≤ T.size() ≤ 10, 1 ≤ Ti ≤ 10.`
-   Test 4 -> 6: `1 ≤ T.size() ≤ 103, 1 ≤ Ti ≤ 103.`
-   Test 7 -> 9: `1 ≤ T.size() ≤ 10, 1 ≤ Ti ≤ 106.`
-   Test 10 -> 12: `1 ≤ T.size() ≤ 102, 1 ≤ Ti ≤ 109.`
-   Test 13 -> 15: `1 ≤ T.size() ≤ 105, 1 ≤ Ti ≤ 109.`
-   Test 16 -> 18: `1 ≤ T.size() ≤ 105, 1 ≤ Ti ≤ 1015.`
-   Test 19: `T.size() = 105.`', 3, NULL, '[{"time": "6000", "input": "[3,1,5]", "point": 5, "output": "[4,1,7]"}, {"time": "6000", "input": "[9,5,3,1,2]", "point": 5, "output": "[15,7,4,1,2]"}]', '["bit manipulation"]', NULL, NULL, NULL, 'active', '2022-05-25 17:48:08.558701+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 17:48:08.558701+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('a6927850-6e14-4c46-9d8f-9a55c6f5bd78', ' maxComNumbers', 'Một số được gọi là composite number khi nó không phải là số nguyên tố và là số nguyên dương lớn hơn 1(ví dụ 4, 6, 8, 9, ...). Cho một số nguyên dương n, hãy tính số lượng số composite number để tạo thành số n nhiều nhất có thể. Nếu không thể tạo ra được n, hãy trả về -1.
Ví dụ: 
-   Với `n = 8`. Đầu ra `maxComNumbers(n) = 2`
     Giải thích: Số 8 có thể tạo thành từ 2 số 4
-   Với `n = 5`. Đầu ra `maxComNumbers(n) = -1`
     Giải thích: Số 5 không thể tạo thành từ các số composite number
Đầu vào/Đầu ra:
-   [Thời gian chạy] 0.5s với C++, 3s với Java và C#, 4s với Python, Go và JavaScript.
-   [Đầu vào]  Long long n`\
    1 <= n <= 10^18`
-   [Đầu ra] Integer\
    Số lượng số composite lớn nhất
', 2, NULL, '[{"time": "3000", "input": "8", "point": 5, "output": "2"}, {"time": "3000", "input": "5", "point": 5, "output": "-1"}]', '["math", "algorithm"]', NULL, NULL, NULL, 'active', '2022-05-25 17:51:37.261973+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 17:51:37.261973+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('ab26d91e-5107-43e7-a5af-a5888ecebf5b', ' rectangular', 'You have a rectangular prism with the integer side lengths and you know the areas of `3` faces that share the same vertice. Your task is to calculate the sum of the length of the sides of the rectangular prism.
![Káº¿t quáº£ hÃ¬nh áº£nh cho HÃ¬nh há»p chá»¯ nháº­t](https://upload.wikimedia.org/wikipedia/vi/8/84/H%C3%ACnh_h%E1%BB%99p_ch%E1%BB%AF_nh%E1%BA%ADt.png)
Example
-   For `s1 = 1, s2 = 1, s3 = 1`, the output should be `rectangular(s1, s2, s3) = 12\
    `3 faces of the rectangular have the same `area = 1` so the lengths of all sides of the rectangular are 1. The rectangular has 12 sides so the answer is 12. 
Input/Output
-   [execution time limit] 0.5s
-   [input] integer s1, s2, s3\
    areas of the three face that share the same vertice.\
    `(1 ≤ s1, s2, s3 ≤ 10^4)`
-   [output] integer\
    the sum of the length of the sides of the rectangular prism.', 3, NULL, '[{"time": "3000", "input": "1 1 1", "point": 5, "output": "12"}, {"time": "3000", "input": "4 6 6", "point": 5, "output": "28"}]', '["math", "algorithm"]', NULL, NULL, NULL, 'active', '2022-05-25 17:53:05.274866+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 17:53:05.274866+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('e5921a1e-ed37-4faf-8712-7327b87f0762', ' maxArea', 'Given `n` non-negative integers `a1, a2, ..., an `, where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of line i is at `(i, ai)` and `(i, 0)`. Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.
Example
-   For `lines = [1,8,6,2,5,4,8,3,7]`, the output should be `maxArea(lines) = 49`.
      ![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)
Input/Output
-   [execution time limit] 1 second
-   [input] array.integer heights
    *Guaranteed constraints:*
`heights.length <= 100000`
`1 ≤ heights[i] ≤ 100000.`
-   [output] integer', 2, NULL, '[{"time": "12000", "input": "[1,8,6,2,5,4,8,3,7]", "point": 5, "output": "49"}, {"time": "12000", "input": "[4, 8, 5, 7, 5, 19, 1, 16, 19, 6]", "point": 5, "output": "57"}]', '["Array", "Two Pointers"]', NULL, NULL, NULL, 'active', '2022-05-25 17:53:59.26558+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 17:53:59.26558+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('460fd746-b5b3-42eb-a9d3-088589a84a31', 'CHALLENGE #11: Finding the best algorithm - Competing other programers', 'Nhiệm vụ của bạn là viết một chương trình của một từ điển đơn giản, thực hiện các lệnh sau:
-   `insert str`: chèn xâu `str` vào từ điển hiện tại.
-   `find str`: nếu hiện tại, xâu `str` nằm trong từ điển thì trả về `"yes"`, ngược lại là `"no"`.
Với đầu vào là một tập các lệnh `insert` và `find` và ban đầu từ điển sẽ rỗng. Bạn hãy trả về một mảng kết quả có `n` phần tử, trong đó `n` chính là số lượng lệnh `find` có trong input và kết quả thứ `i` chính là lần `find` thứ `i`.
Lưu ý: Các lệnh sẽ được thực hiện theo thứ tự.
Ví dụ:
-   `arr_op = ["insert A", "insert T", "insert C", "find G", "find A"]` thì `dictionary(arr_op) = ["no", "yes"]`\
    Giải thích: Ban đầu từ điển `S` là một tập rỗng\
    `insert A -> S = ["A"]`\
    `insert T -> S = ["A", "T"]`\
    `insert C -> S = ["A", "T", "C"]`\
    Lần `find` thứ nhất: `find G` -> `"no"`. Không tồn tại xâu `"G"` trong tập `S`\
    Lần `find` thứ hai: `find A` -> `"yes"`. Tồn tại xâu `"A"` trong tập `S`.\
    Nên kết quả trả về là `["no", "yes"]`
Đầu vào/Đầu ra:
-   [Giới hạn thời gian chạy]: 1 giây với C++, 6 giây với Java và C#, 8s với Python, GO và Js.
-   [Giới hạn bộ nhớ]: 128 MB
-   [Đầu vào] array of strings arr_op\
    `1 ≤ arr_op.size() ≤ 2 x 105`\
    Đảm bảo `arr[i]` chỉ có thể là một trong `2` dạng `"insert str"` hoặc `"find str"`\
    `1 ≤ str.size() ≤ 12`\
    Đảm bảo xâu `str` chỉ là chứa `1` trong `4` ký tự `''A'', ''C'', ''G'', ''T''`.
-   [Đầu ra] Array of String\
    Một mảng có n phần tử, trong đó n là số lượng lệnh find và phần từ thứ i là kết quả của lần find thứ i.', 1, NULL, '[{"time": "6000", "input": "[\"insert A\", \"insert T\", \"insert C\", \"find G\", \"find A\"] ", "point": 5, "output": "[\"no\", \"yes\"]"}, {"time": "6000", "input": "[\"insert AAA\",\"insert AAC\",\"insert AGA\",\"insert AGG\",\"insert TTT\",\"find AAA\",\"find CCC\",\"find CCC\",\"insert CCC\",\"find CCC\",\"find CC\",\"insert T\",\"find TTT\",\"find T\",\"find A\"]", "point": 5, "output": "[\"yes\",\"no\",\"no\",\"yes\",\"no\",\"yes\",\"yes\",\"no\"]"}]', '["string"]', NULL, NULL, 'a8cc1229-0bb0-43f1-a4dd-b88d3db0394f', 'active', '2022-05-25 18:01:45.307642+00', 'b955cf7a-4dcb-464b-8f56-6021cf021cde', '2022-05-25 18:03:40.364+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4');
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('0859ed8b-7c80-4487-9deb-5f48df40d771', 'Finding the best algorithm - Competing others programers', 'Cho dãy `a` gồm các số nguyên không âm `a[1], a[2], ..., a[n]` và `m` câu hỏi được lưu trong ma trận `Q`.
Ứng với mỗi bộ 2 số `(l, r)` trong `Q` là một câu hỏi yêu cầu bạn hãy tính tổng các số từ `a[l]` tới `a[r]`. Kết quả trả về sẽ là mảng gồm `m` phần tử, trong đó phần tử thứ `i` chính là kết quả của câu hỏi thứ `i`.
Ví dụ:
-   Với `a = [2, 5, 7, 3], Q = [[2, 2], [2, 4], [1, 3]]` thì output là `sumRange(a, Q) = [5, 15, 14]`.\
    Giải thích:
    -   Câu hỏi thứ nhất: `l = 2, r = 2` => đáp án là `a[2] = 5`.
    -   Câu hỏi thứ hai: `l = 2, r = 4` => đáp án là `a[2] + a[3] + a[4] = 15`. 
    -   Câu hỏi thứ ba: `l = 1, r = 3` => đáp án là `a[1] + a[2] + a[3] = 14`.
Đầu vào/Đầu ra:
-   [Giới hạn thời gian chạy]: 1s với C++, 6s với Java và C#, 8s với Python, GO và Js.
-   [Đầu vào] Array of integers a\
    `1 <= a.size <= 15000`\
    `1 <= a[i] <= 100000`
-   [Đầu vào] Matrix of integers Q\
    `1 <= Q.size <= 15000`\
    `Q[i].size = 2`\
    `1 <= Q[i][j] <= 15000`
-   [Đầu ra] Array of integer
[](https://codelearn.io/challenge/challenge-13-finding-the-best-algorithm-competing-other-programers/2758215#)', 1, NULL, '[{"time": "3000", "input": "[2, 5, 7, 3] [[2, 2], [2, 4], [1, 3]]", "point": 5, "output": "[5, 15, 14]"}, {"time": "3000", "input": "[15, 16, 15, 11, 15, 3, 19, 13, 15, 1] [[2, 5], [3, 4], [1, 9]]", "point": 5, "output": "[57,26,122]"}]', '["Algorithm", "Segment-tree", "challenge"]', NULL, NULL, '8c7755b1-aaff-4023-b496-00d700e1dd1a', 'active', '2022-05-25 18:06:52.026124+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 18:06:52.026124+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('d4a6e1b3-b18d-449c-9949-c088ada977d1', 'Finding algorithm - Competing other programers', 'Cho mảng các số nguyên `arr` và số nguyên `k`, bạn hãy viết hàm trả về mảng bao gồm các phần tử lớn nhất của tất cả các mảng con có độ dài `k` trong `arr` (xem ví dụ để hiểu rõ hơn).
Ví dụ
-   Với `arr = [7, 2, 6, 5, 1, 3], k = 3` thì output là `slidingWindowMax(arr, k) = [7, 6, 6, 5]`.\
    Giải thích:
    -   `max(arr[0], arr[1], arr[2]) = 7`.
    -   `max(arr[1], arr[2], arr[3]) = 6`.
    -   `max(arr[2], arr[3], arr[4]) = 6`.
    -   `max(arr[3], arr[4], arr[5]) = 5`.
-   Với `arr = [7, 9, 8, 2, 6, 5, 3], k = 2` thì output là `slidingWindowMax(arr, k) = [9, 9, 8, 6, 6, 5]`.
Đầu vào/Đầu ra:
-   [Giới hạn thời gian chạy]: 1s với C++, 6s với Java và C#, 8s với Python, GO và Js.
-   [Đầu vào] Array of integers arr\
    `1 <= arr.size <= 200000`\
    `0 <= arr[i] <= 1000000000`
-   [Đầu vào] Interger k\
    `1 <= k <= arr.size`\
    [Đầu ra] Array of integer', 2, NULL, '[{"time": "3000", "input": "[7, 2, 6, 5, 1, 3] 3", "point": 5, "output": "[7, 6, 6, 5]"}, {"time": "3000", "input": "[7, 9, 8, 2, 6, 5, 3] 2", "point": 5, "output": "[9, 9, 8, 6, 6, 5]"}]', '["Challenge"]', NULL, NULL, '20ed92e7-c39d-4759-9823-e1506729f573', 'active', '2022-05-25 18:08:41.353933+00', 'aa89ede9-26f1-4660-9aba-75b21f53e6c4', '2022-05-25 18:08:41.353933+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('d59248ee-cc80-4907-b836-a0790771d63b', ' findPhoneNumbers', 'Bình có một danh bạ điện thoại dùng để lưu thông tin về các người bạn. Các số điện thoại trong danh bạ của Bình đều là số có 9 chữ số và không được bắt đầu bởi chữ số 0.
Với hệ điều hành mà Bình đang sử dụng, khi bấm tìm kiếm một số điện thoại nào đó trong danh bạ thì màn hình sẽ hiển thị ra tất cả các số điện thoại mà có các chữ số liên tiếp trùng với số được tìm kiếm. Ví dụ trong danh bạ của Bình có 3 số điện thoại là 100000007, 123456789, 100012345 thì:
-   Khi bấm 00 thì màn hình sẽ hiển thị ra 2 số là 100000007 và 100012345.
-   Khi bấm 345 thì màn hình sẽ hiển thị ra 2 số là 123456789 và 100012345.
-   Khi bấm 07 thì chỉ có 1 số điện thoại được hiển thị ra màn hình là 100000007
Biết thông tin về các số điện thoại trong danh bạ được lưu dưới dạng mảng các xâu `arr`, ứng với mỗi số điện thoại trong danh bạ, bạn hãy xác định xâu có độ dài ngắn nhất mà khi Bình tìm kiếm thì màn hình sẽ chỉ hiển thị đúng số điện thoại này. Nếu có nhiều hơn một xâu thỏa mãn thì lấy xâu có giá trị số nguyên nhỏ nhất.
Kết quả trả về sẽ là mảng các xâu tương ứng với mỗi số điện thoại.
Ví dụ:
-   Với `arr = ["100000007", "123456789", "100012345"]` thì output là `findPhoneNumbers(arr) = ["07", "6", "01"]`.\
    Giải thích:
    -   Khi bấm `"07"` thì chỉ có số điện thoại thứ nhất hiện ra.\
        Lưu ý: Bạn cũng có thể bấm các số khác như `"007", "10000", ...` nhưng các số này không có độ dài nhỏ nhất.
    -   Khi bấm `"6"` thì chỉ có số điện thoại thứ hai hiện ra.
    -   Khi bấm `"01"` thì chỉ có số điện thoại thứ 3 hiện ra.
-   Với `arr = ["101122334", "230415555"]` thì output là `findPhoneNumbers(arr) = ["01", "5"]`.\
    Lưu ý: với số điện thoại đầu tiên bạn có thể bấm `"10", "11", "22", ...` nhưng các số này đều có giá trị nguyên lớn hơn `"01"` nên kết quả của số đầu tiên sẽ là `"01"`.
Đầu vào/Đầu ra
-   [Giới hạn thời gian chạy] 0.5 giây với C++, 3 giây với Java và C#, 4s với Python, GO và Js.
-   [Đầu vào] Array of strings arr\
    `1 <= arr.size <= 500`\
    `"100000000" <= arr[i] <= "999999999"`\
    Đầu vào luôn đảm bảo các số điện thoại trong danh bạ là khác nhau.
-   [Đầu ra] Array of strings
[](https://codelearn.io/challenge/thu-thach-18-tim-thuat-toan-toi-uu-thu-tai-lap-trinh-vien/3749133#)', 2, NULL, '[{"time": "3000", "input": "[\"100000007\", \"123456789\", \"100012345\"]", "point": 5, "output": "[\"07\",\"6\",\"01\"]"}, {"time": "3000", "input": "[\"101122334\", \"230415555\"]", "point": 5, "output": "[\"01\", \"5\"]"}]', '["implementation", " sorting"]', '1137e137-4d7e-4512-99d9-67abb17b60b2', NULL, NULL, 'active', '2022-05-25 18:30:36.024108+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 18:30:36.024108+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('f57e5d41-ca9e-4237-b162-8956dcad4c1a', 'Mảng : [Cpp Advanced] array6', '### Bài tập
Cho mảng các số nguyên `n` phần tử được nhập từ bàn phím (mảng này được cấp phát động và quản lý thông qua con trỏ `arr`), bạn hãy viết chương trình tính tổng của các phần tử trong mảng và hiển thị ra màn hình:
```
Sum = {P}
```
Với `{P}` là tổng của các phần tử trong mảng.
Nếu bạn chưa biết về khái niệm cấp phát bộ nhớ động thì có thể xem phần lý thuyết bên dưới.
### Lý thuyết
Trước hết bạn hãy xem lại cách khai báo mảng thông thường:
```
// Khai báo mảng a 100 phần tử
int arr[100];
```
Nhược điểm:
-   Với cách khai báo này số phần tử của mảng luôn phải cố định, bạn không thể thay đổi kích thước của mảng khi chương trình đang chạy. Ví dụ vì lý do nào đó mà sau này mảng `arr` cần tới `101` phần tử thì bạn chỉ có cách tắt chương trình đi và code lại thành `int arr[101];` (do mảng không tự tăng kích thước được).
-   Mảng sẽ được cấp phát trên vùng nhớ Stack, và kích thước của vùng nhớ này là nhỏ nên bạn không thể khai báo mảng có nhiều phần tử được. Ví dụ bạn hãy thử chạy chương trình sau:
    ```
    #include <iostream>
    using namespace std;
    int main() {
        int arr[10000000];
        return 0;
    }
    ​
    ```
    Chương trình này sẽ báo lỗi do kích thước của vùng nhớ Stack không đủ để cấp phát bộ nhớ cho mảng `a`.
Ưu điểm:
-   Mảng được cấp phát trên vùng nhớ Stack nên sẽ có tốc độ truy xuất nhanh (vùng nhớ stack tuy có kích thước nhỏ nhưng lại có tốc độ truy xuất nhanh hơn các vùng nhớ khác).
-   Bộ nhớ được chương trình quản lý tự động (vùng nhớ được cấp phát cho mảng sẽ được chương trình giải phóng khi không dùng nữa).
Mảng được cấp phát động sẽ giải quyết được những nhược điểm trên nhưng cũng có một số nhược điểm. Trước hết bạn hãy xem cách để cấp phát bộ nhớ động cho mảng:
```
// Cấp phát bộ nhớ động cho mảng có 10000000 phần tử
// Để cấp phát bộ nhớ động cho mảng ta sử dụng toán tử new
int* arr = new int[10000000];
```
Đoạn code trên cấp phát bộ nhớ động cho mảng có `10000000` phần tử, lưu ý rằng `arr` không phải là một mảng, `arr` là một con trỏ trỏ tới vùng nhớ được cấp phát động (trỏ tới phần tử đầu tiên của mảng được cấp phát động) hay hiểu cách khác `arr` là con trỏ dùng để quản lý mảng có `10000000` phần tử.
Bạn có thể sử dụng mảng được cấp phát động giống như mảng thông thường:
```
#include <iostream>
using namespace std;
int main() {
    // Cấp phát động cho mảng có 10 phần tử
    int* arr = new int[10];
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }
    for (int i = 0; i < 10; i++) {
        cout << arr[i] << " ";
    }
    // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
    delete[]arr;
    return 0;
}
```
Kết quả khi chạy chương trình:
```
0 1 2 3 4 5 6 7 8 9
```
Ưu điểm của cấp phát bộ nhớ động
-   Số phần tử của mảng không nhất thiết phải cố định. Ví dụ:
    ```
    #include <iostream>
    using namespace std;
    int main() {
        int n;
        cin >> n;
        // Cấp phát động cho mảng có n phần tử
        int* arr = new int[n];
        // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
        delete[]arr;
        return 0;
    }
    ​​
    ```
    Có thể thấy trong ví dụ trên số phần tử của mảng được cấp phát động là một biến được nhập từ bàn phím.
-   Bạn có thể thay đổi kích thước mảng khi chương trình đang chạy (bản chất là cho con trỏ tới vùng nhớ khác, ví dụ nếu bạn cần tăng kích thước của mảng thì bạn chỉ cần cho con trỏ trỏ tới vùng nhớ có kích thước lớn hơn).
-   Mảng được cấp phát trên vùng nhớ Heap mà vùng nhớ Heap là vùng nhớ có kích thước lớn nhất trong các vùng nhớ nên với cấp phát động bạn có thể khai báo mảng với nhiều phần tử. Ví dụ:
    ```
    #include <iostream>
    using namespace std;
    int main() {
        int* arr = new int[10000000];
        // Giải phóng bộ nhớ được cấp phát động khi không sử dụng
        delete[]arr;
        return 0;
    }
    ​
    ```
    Chương trình này khi chạy sẽ không báo lỗi do vùng nhớ Heap có kích thước lớn và có thể lưu trữ được mảng có `10000000` phần tử.
Nhược điểm của cấp phát bộ nhớ động
-   Vùng nhớ Heap có tốc độ truy xuất chậm hơn vùng nhớ Stack nên việc truy xuất vào các phần tử trong mảng được cấp phát động sẽ chậm hơn.
-   Bạn phải tự quản lý bộ nhớ được cấp phát động (chương trình sẽ không quản lý cho bạn). Nếu bạn thực hiện cấp phát bộ nhớ động mà không giải phóng thì vùng nhớ này sẽ vẫn còn cho tới khi khởi động lại máy (gây lãng phí bộ nhớ, tệ hơn nữa là tràn bộ nhớ).
Để giải phóng bộ nhớ được cấp phát động bạn dùng toán tử `delete[]`. Ví dụ:
```
#include <iostream>
using namespace std;
int main() {
	// Cấp phát bộ nhớ động cho mảng có 1000 phần tử
	int* arr = new int[1000];
	...
	// Giải phòng bộ nhớ khi không dùng tới
	delete[] arr;
	return 0;
}
​​
```
Do đó khi cấp phát động hãy luôn nhớ phải dùng toán tử `delete[]` để giải phóng bộ nhớ khi không dùng tới nữa.
Lỗi thường gặp khi cấp phát bộ nhớ động:
```
#include<iostream>
using namespace std;
int main() {
	int* arr = new int[1000];
	arr = new int[2000];
	delete[]arr;
	return 0;
}
```
Đoạn code trên sẽ gây ra rò rỉ bộ nhớ do khi gán `arr = new int[2000];` thì vùng nhớ được cấp phát động cho mảng có `1000` phần tử vẫn còn đó, bạn cần giải phóng vùng nhớ này trước khi cho `arr` trỏ tới vùng nhớ mới giống như sau:
```
#include<iostream>
using namespace std;
int main() {
	int* arr = new int[1000];
	delete[]arr;
	arr = new int[2000];
	delete[]arr;
	return 0;
}
```
Đọc tới đây bạn đã hiểu về cấp phát bộ nhớ động và biết cách sử dụng mảng được cấp phát bộ nhớ động, hãy quay lại phần bài tập và làm thử.
Nếu bạn chưa làm được bài này thì có thể xem hướng dẫn ở bên dưới.
### Hướng dẫn
Code mẫu:
```
#include <iostream>
using namespace std;
int main() {
	int n;
	int* arr;
	cin >> n;
	// Thực hiện cấp phát bộ nhớ động cho mảng
	arr = new int[n];
	// Nhập dữ liệu cho mảng
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	// Tính tổng các phần tử trong mảng và lưu vào biến sum
	int sum = 0;
	for (int i = 0; i < n; i++) {
		sum += arr[i];
	}
	cout << "Sum = " << sum;
	delete[]arr;
	return 0;
}
```', 1, NULL, '[{"time": "500", "input": "[1,2,3]", "point": 10, "output": "\"Sum = 6\""}]', '["C++", "array"]', '81039554-2fc7-4b24-b302-34f1ad6bbe4c', NULL, NULL, 'active', '2022-05-25 18:41:25.605361+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 18:41:25.605361+00', NULL);
INSERT INTO public.exercises (id, name, des, level, image, metadata, topic, "contestId", "conceptId", "challengeId", status, "createdAt", "createdBy", "updatedAt", "updatedBy") VALUES ('84de0803-dd3a-47ac-a5a0-f9866ed0c87d', 'Con trỏ', '### Bài tập
Cho biến `a` kiểu số nguyên được nhập từ bàn phím, bạn hãy viết hàm tăng giá trị biến `a` lên `1` và hiển thị ra màn hình:
```
New Value of a: {P}
```
Với `{P}` là giá trị của biến `a` sau khi tăng lên `1`.
### Lý thuyết
Bài này bạn sẽ hiểu được khái niệm về truyền tham trị và truyền tham chiếu trong C++.
Đầu tiên bạn hãy chạy thử chương trình sau:
```
#include <iostream>
using namespace std;
void inc(int a) {
    a++;
}
int main() {
    int a = 5;
    inc(a);
    cout << "Value of a: " << a;
    return 0;
}
```
Kết quả khi chạy chương trình:
```
Value of a: 5
```
Bạn có thể nhận thấy giá trị của biến `a` sau khi gọi hàm `inc()` là không thay đổi (vẫn là 5). Giải thích:
Khi bạn gọi hàm `inc(a);` thì thực chất là bạn đang lấy giá trị tại ô nhớ chứa biến `a` trong hàm `main()` và copy giá trị đó vào ô nhớ chứa biến `a` trong hàm `inc()`, vậy có nghĩa là biến `a` trong hàm `main()` và biến `a` trong hàm `inc()` là 2 biến khác hoàn toàn nhau (không cùng 1 ô nhớ) nên bạn thay đổi biến này cũng sẽ không ảnh hưởng tới biến kia.
Tiếp theo bạn hãy chạy thử chương trình sau:
```
#include <iostream>
using namespace std;
void inc(int* p) {
    (*p)++;
}
int main() {
    int a = 5;
    inc(&a);
    cout << "Value of a: " << a;
    return 0;
}
```
Kết quả khi chạy chương trình:
```
Value of a: 6
```
Có thể thấy giá trị của biến `a` đã được thay đổi sau khi gọi hàm `inc()`, tới đây nhiều bạn mới học lập trình sẽ nghĩ rằng trong đoạn code trên giá trị của biến `a` được thay đổi khi gọi hàm `inc` là do biến `a` được truyền tham chiếu (điều này là sai). Nếu bạn không biết truyền tham trị và tham chiếu là gì thì mình sẽ giải thích:
Truyền tham trị
Như ở ví dụ đầu tiên, biến `a` được truyền tham trị vào hàm `inc()` dẫn tới giá trị của nó không thay đổi, truyền tham trị là truyền giá trị của một biến vào một biến khác (truyền giá trị của một ô nhớ vào một ô nhớ khác).
Truyền tham chiếu
Một biến được truyền tham chiếu khi biến đó có cùng địa chỉ với biến được truyền. Để dễ hiểu hơn hãy xem ví dụ về truyền tham chiếu trong ngôn ngữ lập trình C++ (C++ hỗ trợ truyền tham chiếu thông qua toán tử `&`):
```
#include <iostream>
using namespace std;
void inc(int& a) {
	a++;
	cout << "Address of a in inc function: " << &a << endl;
}
int main() {
	int a = 5;
	inc(a);
	cout << "Address of a in main function: " << &a << endl;
	cout << "Value of a: " << a;
	return 0;
}
```
Kết quả khi chạy chương trình:
```
Address of a in inc function: 010FFAEC
Address of a in main function: 010FFAEC
Value of a: 6
```
Có thể thấy địa chỉ của biến `a` trong hàm `main()` và trong hàm `inc()` là giống hệt nhau nên đây mới đúng là truyền tham chiếu.
Quay lại ví dụ thứ 2: Bạn thay đổi được giá trị của biến `a` trong hàm `inc()` là do bạn truyền địa chỉ của biến `a` vào con trỏ `p` trong hàm `inc()` và lúc này con trỏ `p` đang trỏ tới ô nhớ chứa biến `a` nên những thay đổi mà con trỏ `p` thực hiện sẽ ảnh hưởng tới biến `a` dẫn tới giá trị của a được thay đổi (về bản chất thì đây không phải truyền tham chiếu).
Ngoài C++ ra thì C# cũng hỗ trợ cả truyền tham và truyền tham chiếu, Java và C chỉ hỗ trợ truyền tham trị.
Tổng kết lại, nếu muốn thay đổi giá trị của một biến thông qua hàm thì phải truyền tham chiếu hoặc truyền địa chỉ của biến đó vào hàm.
Đọc tới đây bạn đã có thể làm được bài này, hãy quay lại phần bài tập và làm thử.
Nếu bạn chưa làm được bài này thì có thể xem hướng dẫn ở dưới:
### Hướng dẫn
Code mẫu sử dụng truyền tham chiếu:
```
#include <iostream>
using namespace std;
void change(int &a) {
    a++;
}
int main() {
    int a;
    cin >> a;
    change(a);
    cout << "New value of a: " << a;
    return 0;
}
```
Code mẫu sử dụng truyền tham trị:
```
#include <iostream>
using namespace std;
void change(int* p) {
	(*p)++;
}
int main() {
	int a;
	cin >> a;
	change(&a);
	cout << "New value of a: " << a;
	return 0;
}
```', 2, NULL, '[{"time": "500", "input": "7", "point": 10, "output": "\"New value of a: 8\""}]', '["C++"]', '81039554-2fc7-4b24-b302-34f1ad6bbe4c', NULL, NULL, 'active', '2022-05-25 18:40:05.575672+00', 'b886c67e-f5cf-4246-942f-97d795af3082', '2022-05-25 18:41:56.797+00', 'b886c67e-f5cf-4246-942f-97d795af3082');
SELECT pg_catalog.setval('public.challenges_priority_seq', 6, true);
